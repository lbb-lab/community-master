package life.majiang.community.test.chapter14_thread.runnable;

import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

/**
 * @author: liu bin bin
 * @Date: 2021/3/23 0:40
 * @Description: 有些时候，我们会发现ColorBoxes 几乎陷于停顿状态。在我自己的机器上，这一情况在产生了 10×10 的网格之后发生了。为什么会这样呢？
 * 自然地，我们有理由怀疑AWT 对它做了什么事情。所以这里有一个例子能够测试那个猜测，它产生了较少的线程。代码经过了重新组织，使一个Vector 实现了
 * Runnable ，而且那个Vector 容纳了数量众多的色块，并随机挑选一些进行更新。随后，我们创建大量这些Vector 对象，数量大致取决于我们挑选的网格维数。
 * 结果便是我们得到比色块少得多的线程。所以假如有一个速度的加快，我们   就能立即知道，因为前例的线程数量太多了。如下所示：
 *
 * 在ColorBoxes2 中，我们创建了CBoxVector 的一个数组，并对其初始化，使其容下各个CBoxVector 网格。每个网格都知道自己该“睡眠”多长的时间。
 * 随后为每个 CBoxVector 都添加等量的 Cbox2 对象，而且将每个Vector 都告诉给 go()，用它来启动自己的线程。
 * CBox2 类似CBox——能用一种随机选择的颜色描绘自己。但那就是 CBox2 能够做的全部工作。所有涉及线程的处理都已移至CBoxVector 进行。
 * CBoxVector 也可以拥有继承的 Thread，并有一个类型为 Vector 的成员对象。这样设计的好处就是addElement()和elementAt()方法可以获得特定的参数
 * 以及返回值类型，而不是只能获得常规 Object（它们的名字也可以变得更短）。然而，这里采用的设计表面上看需要较少的代码。除此以外，它会自动保留
 * 一个Vector 的其他所有行为。由于 elementAt()需要大量进行“封闭”工作，用到许多括号，所以随着代码主体的扩充，最终仍有可能需要大量代码。
 * 和以前一样，在我们实现Runnable 的时候，并没有获得与 Thread 配套提供的所有功能，所以必须创建一个新的Thread，并将自己传递给它的构建器，
 * 以便正式“启动”——start()——一些东西。大家在CBoxVector 构建器和 go()里都可以体会到这一点。run()方法简单地选择Vector 里的一个随机元素编号，
 * 并为那个元素调用nextColor()，令其挑选一种新的随机颜色。
 * 运行这个程序时，大家会发现它确实变得更快，响应也更迅速（比如在中断它的时候，它能更快地停下
 * 来）。而且随着网格尺寸的壮大，它也不会经常性地陷于“停顿”状态。因此，线程的处理又多了一项新的  考虑因素：必须随时检查自己有没有“太多的线程”
 * （无论对什么程序和运行平台）。若线程太多，必须试 着使用上面介绍的技术，对程序中的线程数量进行“平衡”。如果在一个多线程的程序中遇到了性能上的问题
 * ，那么现在有许多因素需要检查：
 * (1)	对sleep，yield()以及／或者 wait()的调用足够多吗？
 * (2)	sleep()的调用时间足够长吗？
 * (3)	运行的线程数是不是太多？
 * (4)	试过不同的平台和 JVM 吗？
 * 象这样的一些问题是造成多线程应用程序的编制成为一种“技术活”的原因之一
 *
 * 总结：
 * 何时使用多线程技术，以及何时避免用它，这是我们需要掌握的重要课题。骼它的主要目的是对大量任务进  行有序的管理。通过多个任务的混合使用，可以更有效地利用计算机资源，或者对用户来说显得更方便。资  源均衡的经典问题是在 IO 等候期间如何利用 CPU。至于用户方面的方便性，最经典的问题就是如何在一个长时间的下载过程中监视并灵敏地反应一个“停止”（stop ）按钮的按下。
 * 多线程的主要缺点包括：
 * (1)	等候使用共享资源时造成程序的运行速度变慢。
 * (2)	对线程进行管理要求的额外CPU 开销。
 * (3)	复杂程度无意义的加大，比如用独立的线程来更新数组内每个元素的愚蠢主意。
 * (4)	漫长的等待、浪费精力的资源竞争以及死锁等多线程症状。
 * 线程另一个优点是它们用“轻度”执行切换（100 条指令的顺序）取代了“重度”进程场景切换（1000 条指令）。由于一个进程内的所有线程共享相同的内存空间，所以“轻度”场景切换只改变程序的执行和本地变  量。而在“重度”场景切换时，一个进程的改变要求必须完整地交换内存空间。
 * 线程处理看来好象进入了一个全新的领域，似乎要求我们学习一种全新的程序设计语言——或者至少学习一 系列新的语言概念。由于大多数微机操作系统都提供了对线程的支持，所以程序设计语言或者库里也出现了  对线程的扩展。不管在什么情况下，涉及线程的程序设计：
 * (1)	刚开始会让人摸不着头脑，要求改换我们传统的编程思路；
 * (2)	其他语言对线程的支持看来是类似的。所以一旦掌握了线程的概念，在其他环境也不会有太大的困难。 尽管对线程的支持使Java 语言的复杂程度多少有些增加，但请不要责怪 Java。毕竟，利用线程可以做许多有益的事情。
 * 多个线程可能共享同一个资源（比如一个对象里的内存），这是运用线程时面临的最大的一个麻烦。必须保   证多个线程不会同时试图读取和修改那个资源。这要求技巧性地运用 synchronized（同步）关键字。它是一个有用的工具，但必须真正掌握它，因为假若操作不当，极易出现死锁。
 * 除此以外，运用线程时还要注意一个非常特殊的问题。由于根据Java 的设计，它允许我们根据需要创建任意数量的线程——至少理论上如此（例如，假设为一项工程方面的有限元素分析创建数以百万的线程，这对Java  来说并非实际）。然而，我们一般都要控制自己创建的线程数量的上限。因为在某些情况下，大量线程会将场面变得一团糟，所以工作都会几乎陷于停顿。临界点并不象对象那样可以达到几千个，而是在100  以下。一般情况下，我们只创建少数几个关键线程，用它们解决某个特定的问题。这时数量的限制问题不大。   但在较常规的一些设计中，这一限制确实会使我们感到束手束脚。
 * 大家要注意线程处理中一个不是十分直观的问题。由于采用了线程“调度”机制，所以通过在run()的主循   环中插入对  sleep()的调用，一般都可以使自己的程序运行得更快一些。这使它对编程技巧的要求非常高， 特别是在更长的延迟似乎反而能提高性能的时候。当然，之所以会出现这种情况，是由于在正在运行的线程   准备进入“休眠”状态之前，较短的延迟可能造成“sleep()结束”调度机制的中断。这便强迫调度机制将其 中止，并于稍后重新启动，以便它能做完自己的事情，再进入休眠状态。必须多想一想，才能意识到事情真   正的麻烦程度。
 * 本章遗漏的一件事情是一个动画例子，这是目前程序片最流行的一种应用。然而，Java JDK 配套提供了解决
 * 这个问题的一整套方案（并可播放声音），大家可到java.sun.com 的演示区域下载。此外，我们完全有理由相信未来版本的Java 会提供更好的动画支持——尽管目前的 Web 涌现出了与传统方式完全不同的非 Java、非程序化的许多动画方案。如果想系统学习Java 动画的工作原理，可参考《Core Java——核心Java 》一书，由 Corn ell&Horstmann 编著，Prentice -Hall 于 1997 年出版。若欲更深入地了解线程处理，请参考
 * 《Concurrent Programming in Java——Java 中的并发编程》，由Doug Lea 编著，Addison-Wiseley 于1997 年出版；或者《Java Threads——Java 线程》，Oaks&Wong 编著，O'Reilly 于1997 年出版。
 */
public class ColorBoxes2 extends Frame {
    private CBoxVector[] v;

    public ColorBoxes2(int pause, int grid) {
        setTitle("ColorBoxes2");
        setLayout(new GridLayout(grid, grid));
        v = new CBoxVector[grid];
        for(int i = 0; i < grid; i++)
            v[i] = new CBoxVector(pause);

        for (int i = 0; i < grid * grid; i++) {
            v[i % grid].addElement(new CBox2());
            add((CBox2)v[i % grid].lastElement());
        }

        for(int i = 0; i < grid; i++) v[i].go();
        addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                System.exit(0);
            }
        });
    }

    public static void main(String[] args) {
// Shorter default pause than ColorBoxes:
        int pause = 5;
        int grid = 8;
        if(args.length > 0)
            pause = Integer.parseInt(args[0]);
        if(args.length > 1)
            grid = Integer.parseInt(args[1]);
        Frame f = new ColorBoxes2(pause, grid);
        f.setSize(500, 400);
        f.setVisible(true);
    }

}
